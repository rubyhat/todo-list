{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { Controller } from 'stimulus';\nimport CableReady from 'cable_ready';\nimport serializeForm from 'form-serialize';\nimport { defaultSchema } from './schema';\nimport { getConsumer } from './consumer';\nimport { dispatchLifecycleEvent } from './lifecycle';\nimport { allReflexControllers } from './controllers';\nimport { uuidv4, debounce } from './utils';\nimport Log from './log';\nimport { attributeValue, attributeValues, extractElementAttributes, extractElementDataset, findElement } from './attributes';\nimport { extractReflexName } from './utils'; // A reference to the Stimulus application registered with: StimulusReflex.initialize\n//\n\nvar stimulusApplication; // A reference to the ActionCable consumer registered with: StimulusReflex.initialize or getConsumer\n//\n\nvar actionCableConsumer; // A dictionary of promise data\n//\n\nvar promises = {}; // Indicates if we should log calls to stimulate, etc...\n//\n\nvar debugging = false; // Subscribes a StimulusReflex controller to an ActionCable channel.\n//\n// controller - the StimulusReflex controller to subscribe\n//\n\nvar createSubscription = function createSubscription(controller) {\n  actionCableConsumer = actionCableConsumer || getConsumer();\n  var channel = controller.StimulusReflex.channel;\n  var identifier = JSON.stringify({\n    channel: channel\n  });\n  controller.StimulusReflex.subscription = actionCableConsumer.subscriptions.findAll(identifier)[0] || actionCableConsumer.subscriptions.create(channel, {\n    received: function received(data) {\n      if (!data.cableReady) return;\n\n      if (data.operations.morph && data.operations.morph.length) {\n        if (data.operations.morph[0].stimulusReflex) {\n          var urls = Array.from(new Set(data.operations.morph.map(function (m) {\n            return m.stimulusReflex.url;\n          })));\n          if (urls.length !== 1 || urls[0] !== location.href) return;\n        }\n      }\n\n      CableReady.perform(data.operations);\n    }\n  });\n}; // Extends a regular Stimulus controller with StimulusReflex behavior.\n//\n// Methods added to the Stimulus controller:\n// - stimulate\n// - __perform\n//\n\n\nvar extendStimulusController = function extendStimulusController(controller) {\n  Object.assign(controller, {\n    // Indicates if the ActionCable web socket connection is open.\n    // The connection must be open before calling stimulate.\n    //\n    isActionCableConnectionOpen: function isActionCableConnectionOpen() {\n      return this.StimulusReflex.subscription.consumer.connection.isOpen();\n    },\n    // Invokes a server side reflex method.\n    //\n    // - target - the reflex target (full name of the server side reflex) i.e. 'ReflexClassName#method'\n    // - element - [optional] the element that triggered the reflex, defaults to this.element\n    // - options - [optional] an object that contains at least one of attrs, reflexId, selectors\n    // - *args - remaining arguments are forwarded to the server side reflex method\n    //\n    stimulate: function stimulate() {\n      var url = location.href;\n      var args = Array.from(arguments);\n      var target = args.shift() || 'StimulusReflex::Reflex#default_reflex';\n      var element = args[0] && args[0].nodeType === Node.ELEMENT_NODE ? args.shift() : this.element;\n\n      if (element.type === 'number' && element.validity && element.validity.badInput) {\n        return;\n      }\n\n      var options = {};\n\n      if (args[0] && _typeof(args[0]) == 'object' && Object.keys(args[0]).filter(function (key) {\n        return ['attrs', 'selectors', 'reflexId'].includes(key);\n      })) {\n        var opts = args.shift();\n        Object.keys(opts).forEach(function (o) {\n          return options[o] = opts[o];\n        });\n      }\n\n      var attrs = options['attrs'] || extractElementAttributes(element);\n      var reflexId = options['reflexId'] || uuidv4();\n      var selectors = options['selectors'] || getReflexRoots(element);\n      if (typeof selectors == 'string') selectors = [selectors];\n      var datasetAttribute = stimulusApplication.schema.reflexDatasetAttribute;\n      var dataset = extractElementDataset(element, datasetAttribute);\n      var data = {\n        target: target,\n        args: args,\n        url: url,\n        attrs: attrs,\n        dataset: dataset,\n        selectors: selectors,\n        reflexId: reflexId,\n        permanent_attribute_name: stimulusApplication.schema.reflexPermanentAttribute\n      };\n      var subscription = this.StimulusReflex.subscription;\n      if (!this.isActionCableConnectionOpen()) throw 'The ActionCable connection is not open! `this.isActionCableConnectionOpen()` must return true before calling `this.stimulate()`'; // lifecycle setup\n\n      element.reflexController = this;\n      element.reflexData = data;\n      dispatchLifecycleEvent('before', element);\n      setTimeout(function () {\n        var _ref = element.reflexData || {},\n            params = _ref.params;\n\n        element.reflexData = _objectSpread(_objectSpread({}, data), {}, {\n          params: _objectSpread(_objectSpread({}, params), serializeForm(element.closest('form'), {\n            hash: true,\n            empty: true\n          }))\n        });\n        subscription.send(element.reflexData);\n      });\n\n      if (debugging) {\n        Log.request(reflexId, target, args, this.context.scope.identifier, element);\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        promises[reflexId] = {\n          resolve: resolve,\n          reject: reject,\n          data: data\n        };\n      });\n      if (debugging) promise[\"catch\"](function () {}); // noop default catch\n\n      return promise;\n    },\n    // Wraps the call to stimulate for any data-reflex elements.\n    // This is internal and should not be invoked directly.\n    __perform: function __perform(event) {\n      var element = event.target;\n      var reflex;\n\n      while (element && !reflex) {\n        reflex = element.getAttribute(stimulusApplication.schema.reflexAttribute);\n        if (!reflex || !reflex.trim().length) element = element.parentElement;\n      }\n\n      var match = attributeValues(reflex).find(function (reflex) {\n        return reflex.split('->')[0] === event.type;\n      });\n\n      if (match) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.stimulate(match.split('->')[1], element);\n      }\n    }\n  });\n}; // Registers a Stimulus controller and extends it with StimulusReflex behavior\n//\n// controller - the Stimulus controller\n// options - [optional] configuration\n//\n\n\nvar register = function register(controller) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var channel = 'StimulusReflex::Channel';\n  controller.StimulusReflex = _objectSpread(_objectSpread({}, options), {}, {\n    channel: channel\n  });\n  createSubscription(controller);\n  extendStimulusController(controller);\n}; // Default StimulusReflexController that is implicitly wired up as data-controller for any DOM elements\n// that have configured data-reflex. Note that this default can be overridden when initializing the application.\n// i.e. StimulusReflex.initialize(myStimulusApplication, MyCustomDefaultController);\n//\n\n\nvar StimulusReflexController = /*#__PURE__*/function (_Controller) {\n  _inherits(StimulusReflexController, _Controller);\n\n  var _super = _createSuper(StimulusReflexController);\n\n  function StimulusReflexController() {\n    var _this;\n\n    _classCallCheck(this, StimulusReflexController);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    register(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  return StimulusReflexController;\n}(Controller); // Sets up declarative reflex behavior.\n// Any elements that define data-reflex will automatically be wired up with the default StimulusReflexController.\n//\n\n\nvar setupDeclarativeReflexes = debounce(function () {\n  document.querySelectorAll(\"[\".concat(stimulusApplication.schema.reflexAttribute, \"]\")).forEach(function (element) {\n    var controllers = attributeValues(element.getAttribute(stimulusApplication.schema.controllerAttribute));\n    var reflexes = attributeValues(element.getAttribute(stimulusApplication.schema.reflexAttribute));\n    var actions = attributeValues(element.getAttribute(stimulusApplication.schema.actionAttribute));\n    reflexes.forEach(function (reflex) {\n      var controller = findControllerByReflexString(reflex, allReflexControllers(stimulusApplication, element));\n      var action;\n\n      if (controller) {\n        action = \"\".concat(reflex.split('->')[0], \"->\").concat(controller.identifier, \"#__perform\");\n        if (!actions.includes(action)) actions.push(action);\n      } else {\n        action = \"\".concat(reflex.split('->')[0], \"->stimulus-reflex#__perform\");\n\n        if (!controllers.includes('stimulus-reflex')) {\n          controllers.push('stimulus-reflex');\n        }\n\n        if (!actions.includes(action)) actions.push(action);\n      }\n    });\n    var controllerValue = attributeValue(controllers);\n    var actionValue = attributeValue(actions);\n\n    if (controllerValue && element.getAttribute(stimulusApplication.schema.controllerAttribute) != controllerValue) {\n      element.setAttribute(stimulusApplication.schema.controllerAttribute, controllerValue);\n    }\n\n    if (actionValue && element.getAttribute(stimulusApplication.schema.actionAttribute) != actionValue) element.setAttribute(stimulusApplication.schema.actionAttribute, actionValue);\n  });\n}, 20); // Given a reflex string such as 'click->TestReflex#create' and a list of\n// controllers. It will find the matching controller based on the controller's\n// identifier. e.g. Given these controller identifiers ['foo', 'bar', 'test'],\n// it would select the 'test' controller.\n\nvar findControllerByReflexString = function findControllerByReflexString(reflexString, controllers) {\n  var controller = controllers.find(function (controller) {\n    if (!controller.identifier) return;\n    return extractReflexName(reflexString).toLowerCase() === controller.identifier.toLowerCase();\n  });\n  return controller || controllers[0];\n}; // compute the DOM element(s) which will be the morph root\n// use the data-reflex-root attribute on the reflex or the controller\n// optional value is a CSS selector(s); comma-separated list\n// order of preference is data-reflex, data-controller, document body (default)\n\n\nvar getReflexRoots = function getReflexRoots(element) {\n  var list = [];\n\n  while (list.length === 0 && element) {\n    var reflexRoot = element.getAttribute(stimulusApplication.schema.reflexRootAttribute);\n\n    if (reflexRoot) {\n      if (reflexRoot.length === 0 && element.id) reflexRoot = \"#\".concat(element.id);\n      var selectors = reflexRoot.split(',').filter(function (s) {\n        return s.trim().length;\n      });\n\n      if (selectors.length === 0) {\n        console.error(\"No value found for \".concat(stimulusApplication.schema.reflexRootAttribute, \". Add an #id to the element or provide a value for \").concat(stimulusApplication.schema.reflexRootAttribute, \".\"), element);\n      }\n\n      list = list.concat(selectors.filter(function (s) {\n        return document.querySelector(s);\n      }));\n    }\n\n    element = element.parentElement ? element.parentElement.closest(\"[\".concat(stimulusApplication.schema.reflexRootAttribute, \"]\")) : null;\n  }\n\n  return list;\n}; // Initializes StimulusReflex by registering the default Stimulus controller with the passed Stimulus application.\n//\n// - application - the Stimulus application\n// - options\n//   * controller - [optional] the default StimulusReflexController\n//   * consumer - [optional] the ActionCable consumer\n//\n\n\nvar initialize = function initialize(application) {\n  var initializeOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var controller = initializeOptions.controller,\n      consumer = initializeOptions.consumer,\n      debug = initializeOptions.debug;\n  actionCableConsumer = consumer;\n  stimulusApplication = application;\n  stimulusApplication.schema = _objectSpread(_objectSpread({}, defaultSchema), application.schema);\n  stimulusApplication.register('stimulus-reflex', controller || StimulusReflexController);\n  debugging = !!debug;\n};\n\nif (!document.stimulusReflexInitialized) {\n  document.stimulusReflexInitialized = true;\n  window.addEventListener('load', function () {\n    setupDeclarativeReflexes();\n    var observer = new MutationObserver(setupDeclarativeReflexes);\n    observer.observe(document.documentElement, {\n      attributes: true,\n      childList: true,\n      subtree: true\n    });\n  }); // Trigger success and after lifecycle methods from before events (before-morph, before-inner-html) to ensure we can find a reference\n  // to the source element in case it gets removed from the DOM via morph.\n  // This is safe because the server side reflex completed successfully.\n\n  var beforeDOMUpdateHandler = function beforeDOMUpdateHandler(event) {\n    var _ref2 = event.detail || {},\n        selector = _ref2.selector,\n        stimulusReflex = _ref2.stimulusReflex;\n\n    if (!stimulusReflex) return;\n    var reflexId = stimulusReflex.reflexId,\n        attrs = stimulusReflex.attrs,\n        last = stimulusReflex.last;\n    var element = findElement(attrs);\n    var promise = promises[reflexId];\n    if (!last) return;\n    var response = {\n      element: element,\n      event: event,\n      morphMode: promise && promise.morphMode,\n      data: promise && promise.data\n    };\n\n    if (promise) {\n      delete promises[reflexId];\n      promise.resolve(response);\n    }\n\n    dispatchLifecycleEvent('success', element);\n    if (debugging) Log.success(response);\n  };\n\n  document.addEventListener('cable-ready:before-inner-html', beforeDOMUpdateHandler);\n  document.addEventListener('cable-ready:before-morph', beforeDOMUpdateHandler);\n  document.addEventListener('stimulus-reflex:server-message', function (event) {\n    var _ref3 = event.detail.stimulusReflex || {},\n        reflexId = _ref3.reflexId,\n        attrs = _ref3.attrs,\n        serverMessage = _ref3.serverMessage;\n\n    var subject = serverMessage.subject,\n        body = serverMessage.body;\n    var element = findElement(attrs);\n    var promise = promises[reflexId];\n    var subjects = {\n      error: true,\n      halted: true,\n      nothing: true,\n      success: true\n    };\n    if (element && subject == 'error') element.reflexError = body;\n    var response = {\n      data: promise && promise.data,\n      element: element,\n      event: event,\n      toString: function toString() {\n        return body;\n      }\n    };\n\n    if (promise) {\n      delete promises[reflexId];\n\n      if (subject == 'error') {\n        promise.reject(response);\n      } else {\n        promise.resolve(response);\n      }\n    }\n\n    if (element && subjects[subject]) dispatchLifecycleEvent(subject, element);\n\n    if (debugging) {\n      switch (subject) {\n        case 'error':\n          Log.error(response);\n          break;\n\n        case 'selector':\n          Log.success(response);\n          break;\n\n        case 'nothing':\n          Log.success(response);\n          break;\n\n        case 'halted':\n          Log.success(response, {\n            halted: true\n          });\n          break;\n\n        default:\n          Log.success(response);\n          break;\n      }\n    }\n  });\n}\n\nexport default {\n  initialize: initialize,\n  register: register,\n\n  get debug() {\n    return debugging;\n  },\n\n  set debug(value) {\n    debugging = !!value;\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}