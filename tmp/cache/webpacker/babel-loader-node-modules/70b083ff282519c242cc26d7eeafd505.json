{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport morphdom from 'morphdom';\nvar activeElement;\nvar textInputTagNames = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true\n};\nvar textInputTypes = {\n  'datetime-local': true,\n  'select-multiple': true,\n  'select-one': true,\n  color: true,\n  date: true,\n  datetime: true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  textarea: true,\n  time: true,\n  url: true,\n  week: true\n}; // Indicates if the passed element is considered a text input.\n//\n\nvar isTextInput = function isTextInput(element) {\n  return textInputTagNames[element.tagName] && textInputTypes[element.type];\n}; // Assigns focus to the appropriate element... preferring the explicitly passed focusSelector\n//\n// * focusSelector - a CSS selector for the element that should have focus\n//\n\n\nvar assignFocus = function assignFocus(focusSelector) {\n  var focusElement = focusSelector ? document.querySelector(focusSelector) : activeElement;\n  if (focusElement) focusElement.focus();\n}; // Dispatches an event on the passed element\n//\n// * element - the element\n// * name - the name of the event\n// * detail - the event detail\n//\n\n\nvar dispatch = function dispatch(element, name) {\n  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var init = {\n    bubbles: true,\n    cancelable: true\n  };\n  var evt = new Event(name, init);\n  evt.detail = detail;\n  element.dispatchEvent(evt);\n};\n\nvar xpathToElement = function xpathToElement(xpath) {\n  return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n}; // Return an array with the class names to be used\n//\n// * names - could be a string or an array of strings for multiple classes.\n//\n\n\nvar getClassNames = function getClassNames(names) {\n  return Array(names).flat();\n}; // Indicates whether or not we should morph an element\n// SEE: https://github.com/patrick-steele-idem/morphdom#morphdomfromnode-tonode-options--node\n//\n\n\nvar shouldMorph = function shouldMorph(permanentAttributeName) {\n  return function (fromEl, toEl) {\n    // Skip nodes that are equal:\n    // https://github.com/patrick-steele-idem/morphdom#can-i-make-morphdom-blaze-through-the-dom-tree-even-faster-yes\n    if (fromEl.isEqualNode(toEl)) return false;\n    if (!permanentAttributeName) return true;\n    var permanent = fromEl.closest(\"[\".concat(permanentAttributeName, \"]\")); // only morph attributes on the active non-permanent text input\n\n    if (!permanent && isTextInput(fromEl) && fromEl === activeElement) {\n      var ignore = {\n        value: true\n      };\n      Array.from(toEl.attributes).forEach(function (attribute) {\n        if (!ignore[attribute.name]) fromEl.setAttribute(attribute.name, attribute.value);\n      });\n      return false;\n    }\n\n    return !permanent;\n  };\n}; // Morphdom Callbacks ........................................................................................\n\n\nvar DOMOperations = {\n  // Notifications\n  consoleLog: function consoleLog(config) {\n    var message = config.message,\n        level = config.level;\n    level && ['warn', 'info', 'error'].includes(level) ? console[level](message) : console.log(message);\n  },\n  notification: function notification(config) {\n    var title = config.title,\n        options = config.options;\n    dispatch(document, 'cable-ready:before-notification', config);\n    var permission;\n    Notification.requestPermission().then(function (result) {\n      permission = result;\n      if (result === 'granted') new Notification(title || '', options);\n      dispatch(document, 'cable-ready:after-notification', _objectSpread(_objectSpread({}, config), {}, {\n        permission: permission\n      }));\n    });\n  },\n  // Cookies .................................................................................................\n  setCookie: function setCookie(config) {\n    var cookie = config.cookie;\n    dispatch(document, 'cable-ready:before-set-cookie', config);\n    document.cookie = cookie;\n    dispatch(document, 'cable-ready:after-set-cookie', config);\n  },\n  // DOM Events ..............................................................................................\n  dispatchEvent: function dispatchEvent(config) {\n    var element = config.element,\n        name = config.name,\n        detail = config.detail;\n    dispatch(element, name, detail);\n  },\n  // Element Mutations .......................................................................................\n  morph: function morph(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        childrenOnly = detail.childrenOnly,\n        focusSelector = detail.focusSelector,\n        permanentAttributeName = detail.permanentAttributeName;\n    var template = document.createElement('template');\n    template.innerHTML = String(html).trim();\n    dispatch(element, 'cable-ready:before-morph', _objectSpread(_objectSpread({}, detail), {}, {\n      content: template.content\n    }));\n    var parent = element.parentElement;\n    var ordinal = Array.from(parent.children).indexOf(element);\n    morphdom(element, template.content, {\n      childrenOnly: !!childrenOnly,\n      onBeforeElUpdated: shouldMorph(permanentAttributeName)\n    });\n    assignFocus(focusSelector);\n    dispatch(parent.children[ordinal], 'cable-ready:after-morph', _objectSpread(_objectSpread({}, detail), {}, {\n      content: template.content\n    }));\n  },\n  innerHtml: function innerHtml(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-inner-html', detail);\n    element.innerHTML = html;\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-inner-html', detail);\n  },\n  outerHtml: function outerHtml(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-outer-html', detail);\n    var parent = element.parentElement;\n    var ordinal = Array.from(parent.children).indexOf(element);\n    element.outerHTML = html;\n    assignFocus(focusSelector);\n    dispatch(parent.children[ordinal], 'cable-ready:after-outer-html', detail);\n  },\n  textContent: function textContent(detail) {\n    var element = detail.element,\n        text = detail.text;\n    dispatch(element, 'cable-ready:before-text-content', detail);\n    element.textContent = text;\n    dispatch(element, 'cable-ready:after-text-content', detail);\n  },\n  insertAdjacentHtml: function insertAdjacentHtml(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        html = detail.html,\n        position = detail.position,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-insert-adjacent-html', detail);\n    element.insertAdjacentHTML(position || 'beforeend', html);\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-insert-adjacent-html', detail);\n  },\n  insertAdjacentText: function insertAdjacentText(detail) {\n    var element = detail.element,\n        text = detail.text,\n        position = detail.position;\n    dispatch(element, 'cable-ready:before-insert-adjacent-text', detail);\n    element.insertAdjacentText(position || 'beforeend', text);\n    dispatch(element, 'cable-ready:after-insert-adjacent-text', detail);\n  },\n  remove: function remove(detail) {\n    activeElement = document.activeElement;\n    var element = detail.element,\n        focusSelector = detail.focusSelector;\n    dispatch(element, 'cable-ready:before-remove', detail);\n    element.remove();\n    assignFocus(focusSelector);\n    dispatch(element, 'cable-ready:after-remove', detail);\n  },\n  setProperty: function setProperty(detail) {\n    var element = detail.element,\n        name = detail.name,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-property', detail);\n    if (name in element) element[name] = value;\n    dispatch(element, 'cable-ready:after-set-property', detail);\n  },\n  setValue: function setValue(detail) {\n    var element = detail.element,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-value', detail);\n    element.value = value;\n    dispatch(element, 'cable-ready:after-set-value', detail);\n  },\n  // Attribute Mutations .....................................................................................\n  setAttribute: function setAttribute(detail) {\n    var element = detail.element,\n        name = detail.name,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-attribute', detail);\n    element.setAttribute(name, value);\n    dispatch(element, 'cable-ready:after-set-attribute', detail);\n  },\n  removeAttribute: function removeAttribute(detail) {\n    var element = detail.element,\n        name = detail.name;\n    dispatch(element, 'cable-ready:before-remove-attribute', detail);\n    element.removeAttribute(name);\n    dispatch(element, 'cable-ready:after-remove-attribute', detail);\n  },\n  // CSS Class Mutations .....................................................................................\n  addCssClass: function addCssClass(detail) {\n    var _element$classList;\n\n    var element = detail.element,\n        name = detail.name;\n    dispatch(element, 'cable-ready:before-add-css-class', detail);\n\n    (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(getClassNames(name)));\n\n    dispatch(element, 'cable-ready:after-add-css-class', detail);\n  },\n  removeCssClass: function removeCssClass(detail) {\n    var _element$classList2;\n\n    var element = detail.element,\n        name = detail.name;\n    dispatch(element, 'cable-ready:before-remove-css-class', detail);\n\n    (_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray(getClassNames(name)));\n\n    dispatch(element, 'cable-ready:after-remove-css-class', detail);\n  },\n  // Style Mutations .......................................................................................\n  setStyle: function setStyle(detail) {\n    var element = detail.element,\n        name = detail.name,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-style', detail);\n    element.style[name] = value;\n    dispatch(element, 'cable-ready:after-set-style', detail);\n  },\n  setStyles: function setStyles(detail) {\n    var element = detail.element,\n        styles = detail.styles;\n    dispatch(element, 'cable-ready:before-set-styles', detail);\n\n    for (var _i2 = 0, _Object$entries = Object.entries(styles); _i2 < _Object$entries.length; _i2++) {\n      var _ref3 = _Object$entries[_i2];\n\n      var _ref2 = _slicedToArray(_ref3, 2);\n\n      var name = _ref2[0];\n      var value = _ref2[1];\n      element.style[name] = value;\n    }\n\n    dispatch(element, 'cable-ready:after-set-styles', detail);\n  },\n  // Dataset Mutations .......................................................................................\n  setDatasetProperty: function setDatasetProperty(detail) {\n    var element = detail.element,\n        name = detail.name,\n        value = detail.value;\n    dispatch(element, 'cable-ready:before-set-dataset-property', detail);\n    element.dataset[name] = value;\n    dispatch(element, 'cable-ready:after-set-dataset-property', detail);\n  }\n};\n\nvar perform = function perform(operations) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    emitMissingElementWarnings: true\n  };\n\n  for (var name in operations) {\n    if (operations.hasOwnProperty(name)) {\n      var entries = operations[name];\n\n      for (var i = 0; i < entries.length; i++) {\n        var detail = entries[i];\n\n        try {\n          if (detail.selector) {\n            detail.element = detail.xpath ? xpathToElement(detail.selector) : document.querySelector(detail.selector);\n          } else {\n            detail.element = document;\n          }\n\n          if (detail.element || options.emitMissingElementWarnings) DOMOperations[name](detail);\n        } catch (e) {\n          if (detail.element) console.log(\"CableReady detected an error in \".concat(name, \"! \").concat(e.message));else console.log(\"CableReady \".concat(name, \" failed due to missing DOM element for selector: '\").concat(detail.selector, \"'\"));\n        }\n      }\n    }\n  }\n};\n\nexport default {\n  perform: perform,\n  isTextInput: isTextInput,\n  DOMOperations: DOMOperations\n};","map":null,"metadata":{},"sourceType":"module"}